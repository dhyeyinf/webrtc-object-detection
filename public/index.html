<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Object Detection Demo</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      color: white;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    
    #remoteVideo {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
    }
    
    #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      max-width: 300px;
      z-index: 1000;
    }
    
    #status {
      color: #0f0;
      margin-bottom: 5px;
    }
    
    #metrics {
      color: #ff0;
      font-size: 12px;
    }
    
    #metrics div {
      margin: 2px 0;
    }
    
    .qr-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      background: rgba(255, 255, 255, 0.9);
      color: black;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }
    
    .controls {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 5px;
    }
    
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 8px 12px;
      margin: 2px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
    }
    
    button:hover {
      background: #0056b3;
    }
    
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    
    @media (max-width: 768px) {
      #ui {
        font-size: 12px;
        max-width: 250px;
      }
      
      .controls {
        bottom: 5px;
        right: 5px;
        padding: 5px;
      }
      
      button {
        padding: 6px 10px;
        font-size: 11px;
      }
    }
  </style>
</head>
<body>
  <div id="container">
    <video id="remoteVideo" autoplay playsinline muted></video>
    <canvas id="overlayCanvas"></canvas>
    
    <div id="ui">
      <div id="status">Initializing...</div>
      <div id="metrics">
        <div>Processed Frames: 0</div>
        <div>FPS: 0.00</div>
        <div>Queue Size: 0</div>
        <div>Mode: server</div>
      </div>
    </div>
    
    <div class="controls">
      <button id="resetMetrics" onclick="resetMetrics()">Reset Metrics</button>
      <button id="toggleProcessing" onclick="toggleProcessing()">Pause</button>
      <button id="downloadMetrics" onclick="downloadMetrics()">Download Metrics</button>
    </div>
  </div>

  <!-- Include required scripts -->
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
  <script src="client.js"></script>
  
  <script>
    // Additional UI functions
    let processingPaused = false;
    
    function resetMetrics() {
      fetch('/metrics/reset', { method: 'POST' })
        .then(response => response.json())
        .then(data => {
          console.log('Metrics reset:', data);
          // Reset client-side metrics
          processedFrames = 0;
          startTime = Date.now();
          updateMetrics();
        })
        .catch(error => console.error('Reset metrics error:', error));
    }
    
    function toggleProcessing() {
      processingPaused = !processingPaused;
      const button = document.getElementById('toggleProcessing');
      
      if (processingPaused) {
        button.textContent = 'Resume';
        updateStatus('Processing paused');
        isProcessing = true; // Prevent new frames
      } else {
        button.textContent = 'Pause';
        updateStatus('Processing resumed');
        isProcessing = false; // Allow new frames
      }
    }
    
    function downloadMetrics() {
      fetch('/metrics')
        .then(response => response.json())
        .then(data => {
          const blob = new Blob([JSON.stringify(data, null, 2)], 
            { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `metrics_${new Date().toISOString().slice(0, 19)}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        })
        .catch(error => console.error('Download metrics error:', error));
    }
    
    // Handle orientation changes on mobile
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        if (video && video.videoWidth && video.videoHeight) {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
        }
      }, 500);
    });
    
    // Handle connection quality
    if (typeof RTCPeerConnection !== 'undefined') {
      setInterval(() => {
        if (pc && pc.connectionState === 'connected') {
          pc.getStats().then(stats => {
            stats.forEach(report => {
              if (report.type === 'inbound-rtp' && report.mediaType === 'video') {
                // Could update UI with connection quality metrics
              }
            });
          }).catch(error => {
            console.log('Stats error:', error);
          });
        }
      }, 5000);
    }
  </script>
</body>
</html>