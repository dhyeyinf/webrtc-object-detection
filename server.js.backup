const express = require('express');
const app = express();
const http = require('http').createServer(app);
const io = require('socket.io')(http);
const QRCode = require('qrcode');
const ort = require('onnxruntime-node');
const path = require('path');
const fs = require('fs');

// Configuration
const MODE = process.env.MODE || 'server';
const PORT = process.env.PORT || 3000;
const NGROK_URL = process.env.NGROK_URL;

// Model and inference setup
let session = null;
const modelPath = path.join(__dirname, 'models', 'yolov5n.onnx');

// COCO class names for YOLOv5
const classNames = [
  'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light',
  'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',
  'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee',
  'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard',
  'tennis racket', 'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
  'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch',
  'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone',
  'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear',
  'hair drier', 'toothbrush'
];

function getLocalIP() {
  const { networkInterfaces } = require('os');
  const nets = networkInterfaces();
  
  for (const name of Object.keys(nets)) {
    for (const net of nets[name]) {
      // Skip internal and non-IPv4 addresses
      if (net.family === 'IPv4' && !net.internal) {
        return net.address;
      }
    }
  }
  return 'localhost';
}


// Initialize model for server mode
async function initializeModel() {
  if (MODE === 'server' && fs.existsSync(modelPath)) {
    try {
      session = await ort.InferenceSession.create(modelPath);
      console.log('Model loaded for server-side inference');
    } catch (error) {
      console.error('Failed to load model:', error);
    }
  }
}

// Process image and return detections
async function processImage(imageData, width, height) {
  if (!session || MODE !== 'server') return [];
  
  try {
    const input = new ort.Tensor('float32', imageData, [1, 3, 640, 640]);
    const results = await session.run({ images: input });
    const output = results.output0.data;
    
    return parseDetections(output, width, height);
  } catch (error) {
    console.error('Inference error:', error);
    return [];
  }
}

function parseDetections(output, originalWidth, originalHeight) {
  const detections = [];
  const numDetections = output.length / 85; // 85 = 5 (bbox + conf) + 80 classes
  
  for (let i = 0; i < numDetections; i++) {
    const offset = i * 85;
    const confidence = output[offset + 4];
    
    if (confidence > 0.5) {
      const x = output[offset];
      const y = output[offset + 1];
      const w = output[offset + 2];
      const h = output[offset + 3];
      
      // Find best class
      let bestClass = 0;
      let bestScore = 0;
      for (let j = 0; j < 80; j++) {
        const score = output[offset + 5 + j];
        if (score > bestScore) {
          bestScore = score;
          bestClass = j;
        }
      }
      
      const finalScore = confidence * bestScore;
      if (finalScore > 0.5) {
        detections.push({
          label: classNames[bestClass] || 'unknown',
          score: finalScore,
          xmin: Math.max(0, (x - w/2) / 640),
          ymin: Math.max(0, (y - h/2) / 640),
          xmax: Math.min(1, (x + w/2) / 640),
          ymax: Math.min(1, (y + h/2) / 640)
        });
      }
    }
  }
  
  return detections;
}

// Metrics tracking
const metrics = {
  frameCount: 0,
  latencies: [],
  startTime: null,
  bandwidthSamples: []
};

app.use(express.static('public'));
app.use(express.json({ limit: '50mb' }));

// WebRTC signaling
io.on('connection', (socket) => {
  console.log('User connected:', socket.id);
  
  socket.on('offer', (data) => {
    socket.broadcast.emit('offer', data);
  });
  
  socket.on('answer', (data) => {
    socket.broadcast.emit('answer', data);
  });
  
  socket.on('ice-candidate', (data) => {
    socket.broadcast.emit('ice-candidate', data);
  });
  
  // Handle frame data for inference
  socket.on('frame-data', async (data) => {
    const { frameId, captureTs, imageData, width, height } = data;
    const recvTs = Date.now();
    
    try {
      const detections = await processImage(imageData, width, height);
      const inferenceTs = Date.now();
      
      const response = {
        frame_id: frameId,
        capture_ts: captureTs,
        recv_ts: recvTs,
        inference_ts: inferenceTs,
        detections: detections
      };
      
      // Track metrics
      metrics.frameCount++;
      metrics.latencies.push(inferenceTs - captureTs);
      
      socket.emit('detection-results', response);
    } catch (error) {
      console.error('Frame processing error:', error);
    }
  });
  
  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
  });
});

// Generate QR code
app.get('/qr', (req, res) => {
  // Get the local IP address
  const localIP = getLocalIP();
  const baseUrl = localIP !== 'localhost' ? `http://${localIP}:${PORT}` : `http://${req.headers.host}`;
  const url = `${baseUrl}?mode=sender`;
  
  QRCode.toDataURL(url, (err, qrUrl) => {
    if (err) {
      res.status(500).send('Error generating QR code');
    } else {
      res.send(`<div style="text-align:center;padding:20px;font-family:Arial,sans-serif;">
        <h2>ðŸ“± Connect Your Phone</h2>
        <h3>Scan this QR code with your phone:</h3>
        <img src="${qrUrl}" style="max-width:300px;border:2px solid #ccc;padding:10px;"/>
        <p><strong>Or type this URL in your phone browser:</strong></p>
        <p style="background:#f0f0f0;padding:10px;border-radius:5px;font-family:monospace;word-break:break-all;">
          <a href="${url}" target="_blank">${url}</a>
        </p>
        <div style="margin-top:30px;padding:15px;background:#e8f4f8;border-radius:8px;max-width:500px;margin:30px auto;">
          <h4>ðŸ“‹ Instructions:</h4>
          <ol style="text-align:left;">
            <li>Make sure your phone and laptop are on the same WiFi (IITJ_WLAN)</li>
            <li>Open your phone's camera or QR scanner</li>
            <li>Scan the QR code above</li>
            <li>Allow camera access when prompted</li>
            <li>You should see your video stream with object detection!</li>
          </ol>
        </div>
        <div style="margin-top:20px;padding:10px;background:#fff3cd;border-radius:5px;">
          <p><strong>Your laptop IP:</strong> ${localIP}</p>
          <p><strong>Server URL:</strong> http://localhost:${PORT}</p>
        </div>
      </div>`);
    }
  });
});

// API endpoint for metrics
app.get('/metrics', (req, res) => {
  const latencies = metrics.latencies.sort((a, b) => a - b);
  const median = latencies[Math.floor(latencies.length / 2)] || 0;
  const p95 = latencies[Math.floor(latencies.length * 0.95)] || 0;
  const fps = metrics.frameCount / ((Date.now() - metrics.startTime) / 1000) || 0;
  
  const result = {
    median_latency_ms: median,
    p95_latency_ms: p95,
    processed_fps: fps,
    total_frames: metrics.frameCount,
    mode: MODE,
    uplink_kbps: 0, // Would need WebRTC stats
    downlink_kbps: 0 // Would need WebRTC stats
  };
  
  res.json(result);
});

// Endpoint to reset metrics
app.post('/metrics/reset', (req, res) => {
  metrics.frameCount = 0;
  metrics.latencies = [];
  metrics.startTime = Date.now();
  metrics.bandwidthSamples = [];
  res.json({ status: 'reset' });
});

// Health check
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    mode: MODE,
    modelLoaded: session !== null 
  });
});

// Initialize and start server
async function startServer() {
  console.log(`Starting server in ${MODE} mode...`);
  
  if (MODE === 'server') {
    await initializeModel();
  }
  
  metrics.startTime = Date.now();
  
  http.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
    console.log(`Mode: ${MODE}`);
    if (NGROK_URL) {
      console.log(`Public URL: ${NGROK_URL}`);
    }
  });
}

startServer().catch(console.error);